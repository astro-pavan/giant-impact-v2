# Calculates the thermodynamic properties and opacity of forsterite using the ANEOS-2019 model and Kraus (2012)
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import RegularGridInterpolator
from scipy.optimize import minimize
import woma
from unyt import g, cm, K, J, kg, Pa

import sys
import os

sys.path.append(f'{os.getcwd()}/aneos-forsterite-2019-1.0.0')
import eostable

print('Loading EOS tables...')

# loads the eos table from file
NewEOS = eostable.extEOStable()  # FIRST make new empty EOS object

# LOAD EXTENDED 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadextsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-EXT.TXT')
# LOAD STANDARD 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadstdsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-STD.TXT')

NewEOS.MODELNAME = 'Forsterite-ANEOS-SLVTv1.0G1'  # string set above in user input
NewEOS.MDQ = np.zeros((NewEOS.NT, NewEOS.ND))  # makes the empty MDQ array

NewEOS.MATID = 1.0
NewEOS.DATE = 190802
NewEOS.VERSION = 0.1
NewEOS.FMN = 70.
NewEOS.FMW = 140.691
NewEOS.R0REF = 3.22
NewEOS.K0REF = 1.1E12
NewEOS.T0REF = 298.
NewEOS.P0REF = 1.E6

NewEOS.loadaneos(aneosinfname='aneos-forsterite-2019-1.0.0/ANEOS.INPUT',
                 aneosoutfname='aneos-forsterite-2019-1.0.0/ANEOS.OUTPUT', silent=True)
woma.load_eos_tables()

# need to change the units to SI
NewEOS.P, NewEOS.S = NewEOS.P * 1e9, NewEOS.S * 1e6
NewEOS.vc.Sl, NewEOS.vc.Sv = NewEOS.vc.Sl * 1e6, NewEOS.vc.Sv * 1e6
NewEOS.vc.Pl, NewEOS.vc.Pv = NewEOS.vc.Pl * 1e9, NewEOS.vc.Pv * 1e9
NewEOS.cp.P, NewEOS.cp.S = NewEOS.cp.P * 1e9, NewEOS.cp.S * 1e6

print('EOS tables loaded')


# calculates rho and T from S and P from the NewEOS table
# does not use unyt
def reverse_EOS_table(S, P):

    # calculates the log of the error between the target (S,P) and all the points in the EOS table
    log_error = np.log10(np.abs(NewEOS.S - S)/S + np.abs(NewEOS.P - P)/P)

    # finds the point in the table with the lowest error (hence closest to the target (S,P))
    k = log_error.argmin()
    ncol = log_error.shape[1]
    i, j = int(k / ncol), int(k % ncol)
    rho_guess, T_guess = NewEOS.rho[j], NewEOS.T[i]

    # wrapper function for woma EOS
    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    # function that calculates the error between guess and target (S,P)
    woma_error = lambda x: np.abs(S_woma(x) - S)/S + np.abs(P_woma(x) - P)/P

    # uses scipy to minimize this error
    res = minimize(woma_error, np.array([rho_guess, T_guess]), method='Nelder-Mead')
    rho_res, T_res = res.x

    # checks error to make sure it is not too big
    S_error = np.abs(S_woma([rho_res, T_res]) - S)/P
    P_error = np.abs(P_woma([rho_res, T_res]) - P)/P
    if S_error > 1 or P_error > 1:
        print(f'ERROR: error at P = {P} S = {S} exceeds 1')
    elif S_error > 0.1 or P_error > 0.1:
        print(f'WARNING: error at P = {P} S = {S} exceeds 0.1')

    return rho_res, T_res


# blank interpolators for rho and T
rho_interpolation, T_interpolation = lambda x: x, lambda x: x


# generates the SP EOS table for interpolation
# does not use unyt
def generate_SP_table():
    global rho_interpolation, T_interpolation

    print('Generating SP EOS table...')

    # produces table points to be calculated
    S = np.linspace(4000, 11000, num=40)  # in J/K/kg
    logP = np.linspace(2, 10, num=40)  # in log10(Pa)
    x, y = np.meshgrid(S, logP)
    rho_table = np.zeros_like(x)
    T_table = np.zeros_like(x)

    # fills table values
    for i in range(x.shape[0]):
        for j in range(x.shape[1]):
            rho_table[j, i], T_table[j, i] = reverse_EOS_table(x[i, j], 10 ** y[i, j])

    rho_interpolation = RegularGridInterpolator((S, logP), rho_table, method='cubic')
    T_interpolation = RegularGridInterpolator((S, logP), T_table, method='cubic')

    print('SP EOS table generated')


generate_SP_table()


# calculates rho from S and P, takes numpy array inputs
# uses unyt
def rho(S, P):
    S.convert_to_mks()
    P.convert_to_mks()
    SP = np.array([S.value, np.log10(P.value)]).T
    return rho_interpolation(SP) * g * cm ** -3


# calculates T from S and P, takes numpy array inputs
# uses unyt
def T(S, P):
    S.convert_to_mks()
    P.convert_to_mks()
    SP = np.array([S.value, np.log10(P.value)]).T
    return T_interpolation(SP) * K


def test():

    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    def test_reverse_EOS(rho_test, T_test):
        S = S_woma([rho_test, T_test]) * J / K / kg
        P = P_woma([rho_test, T_test]) * Pa
        print(S)
        print(P)
        rho_check = rho(S, P)
        T_check = T(S, P)
        assert (rho_check.value - rho_test) / rho_test < 0.1
        assert (T_check.value - T_test) / T_test < 0.1

    test_reverse_EOS(1e-5, 2900)


test()
