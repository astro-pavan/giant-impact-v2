# Calculates the thermodynamic properties and opacity of forsterite using the ANEOS-2019 model and Kraus (2012)
import numpy as np
from scipy.interpolate import RegularGridInterpolator, interp1d
from scipy.optimize import minimize
import woma
from unyt import g, cm, K, J, kg, Pa, m

import sys
import os

sys.path.append(f'{os.getcwd()}/aneos-forsterite-2019-1.0.0')
import eostable

print('Loading EOS tables...')

# loads the eos table from file
NewEOS = eostable.extEOStable()  # FIRST make new empty EOS object

# LOAD EXTENDED 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadextsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-EXT.TXT')
# LOAD STANDARD 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadstdsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-STD.TXT')

NewEOS.MODELNAME = 'Forsterite-ANEOS-SLVTv1.0G1'  # string set above in user input
NewEOS.MDQ = np.zeros((NewEOS.NT, NewEOS.ND))  # makes the empty MDQ array

NewEOS.MATID = 1.0
NewEOS.DATE = 190802
NewEOS.VERSION = 0.1
NewEOS.FMN = 70.
NewEOS.FMW = 140.691
NewEOS.R0REF = 3.22
NewEOS.K0REF = 1.1E12
NewEOS.T0REF = 298.
NewEOS.P0REF = 1.E6

NewEOS.loadaneos(aneosinfname='aneos-forsterite-2019-1.0.0/ANEOS.INPUT',
                 aneosoutfname='aneos-forsterite-2019-1.0.0/ANEOS.OUTPUT', silent=True)
woma.load_eos_tables()

# need to change the units to SI
NewEOS.P, NewEOS.S = NewEOS.P * 1e9, NewEOS.S * 1e6
NewEOS.vc.Sl, NewEOS.vc.Sv = NewEOS.vc.Sl * 1e6, NewEOS.vc.Sv * 1e6
NewEOS.vc.Pl, NewEOS.vc.Pv = NewEOS.vc.Pl * 1e9, NewEOS.vc.Pv * 1e9
P_critical_point, S_critical_point = NewEOS.cp.P * 1e9, NewEOS.cp.S * 1e6

print('EOS tables loaded')


# calculates rho and T from S and P from the NewEOS table
# does not use unyt
def reverse_EOS_table(S, P):
    # calculates the log of the error between the target (S,P) and all the points in the EOS table
    log_error = np.log10(np.abs(NewEOS.S - S) / S + np.abs(NewEOS.P - P) / P)

    # finds the point in the table with the lowest error (hence closest to the target (S,P))
    k = log_error.argmin()
    ncol = log_error.shape[1]
    i, j = int(k / ncol), int(k % ncol)
    rho_guess, T_guess = NewEOS.rho[j], NewEOS.T[i]

    # wrapper function for woma EOS
    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    # function that calculates the error between guess and target (S,P)
    woma_error = lambda x: np.abs(S_woma(x) - S) / S + np.abs(P_woma(x) - P) / P

    # uses scipy to minimize this error
    res = minimize(woma_error, np.array([rho_guess, T_guess]), method='Nelder-Mead')
    rho_res, T_res = res.x

    # checks error to make sure it is not too big
    S_error = np.abs(S_woma([rho_res, T_res]) - S) / P
    P_error = np.abs(P_woma([rho_res, T_res]) - P) / P
    if S_error > 1 or P_error > 1:
        print(f'ERROR: error at P = {P} S = {S} exceeds 1')
    elif S_error > 0.1 or P_error > 0.1:
        print(f'WARNING: error at P = {P} S = {S} exceeds 0.1')

    return rho_res, T_res


# blank interpolators for rho and T
rho_interpolation, T_interpolation = lambda x: x, lambda x: x


# generates the SP EOS table for interpolation
# does not use unyt
def generate_SP_table():
    global rho_interpolation, T_interpolation

    print('Generating SP EOS table...')

    # produces table points to be calculated
    S = np.linspace(4000, 11000, num=40)  # in J/K/kg
    logP = np.linspace(2, 10, num=40)  # in log10(Pa)
    x, y = np.meshgrid(S, logP)
    rho_table = np.zeros_like(x)
    T_table = np.zeros_like(x)

    # fills table values
    for i in range(x.shape[0]):
        for j in range(x.shape[1]):
            rho_table[j, i], T_table[j, i] = reverse_EOS_table(x[i, j], 10 ** y[i, j])

    rho_interpolation = RegularGridInterpolator((S, logP), rho_table, method='cubic')
    T_interpolation = RegularGridInterpolator((S, logP), T_table, method='cubic')

    print('SP EOS table generated')


generate_SP_table()


# calculates rho from S and P, takes numpy array inputs
# uses unyt
def rho(S, P):
    S.convert_to_mks()
    P.convert_to_mks()
    SP = np.array([S.value, np.log10(P.value)]).T
    return rho_interpolation(SP) * g * cm ** -3


# calculates T from S and P, takes numpy array inputs
# uses unyt
def T(S, P):
    S.convert_to_mks()
    P.convert_to_mks()
    SP = np.array([S.value, np.log10(P.value)]).T
    return T_interpolation(SP) * K


# defines the vapor dome - giving P as a function of S
S_vapor_dome = np.concatenate([[0], np.flip(NewEOS.vc.Sl), NewEOS.vc.Sv])
P_vapor_dome = np.concatenate([[1e-7], np.flip(NewEOS.vc.Pl), NewEOS.vc.Pv])
S_P_vapor_dome = interp1d(S_vapor_dome, P_vapor_dome)


# finds the phase
# 0 : invalid region
# 1 : liquid/solid
# 2 : liquid vapor mix
# 3 : vapor
def phase(S, P):
    P.convert_to_units(Pa)
    S.convert_to_units(J / K / kg)

    min_P = 1e-5  # pressures below this are invalid

    result = np.zeros_like(P)
    result = np.where(P <= min_P, 0, result)
    result = np.where(np.logical_and(P < S_P_vapor_dome(S), P > min_P), 2, result)
    result = np.where(np.logical_and(P > S_P_vapor_dome(S), S < S_critical_point), 1, result)
    result = np.where(np.logical_and(P > S_P_vapor_dome(S), S > S_critical_point), 3, result)

    return result


# calculates the absorption of the vapor
# does not use unyt
def alpha_v(rho, T):
    B0 = 6e17  # m^-1
    B1, B2 = 37, -11.6
    rho_n, T_n = 1.9, 4150  # g/cm^3, K
    r, t = rho / rho_n, T / T_n

    return B0 * (r ** (1 / 3)) * t * np.exp(-B1 / t) * np.exp(-B2 * (r / t))


# gives the vapor dome - giving S as a function of P for the liquid and vapor parts
PS_vapor_dome_l, PS_vapor_dome_v = interp1d(NewEOS.vc.Pl, NewEOS.vc.Sl), interp1d(NewEOS.vc.Pv, NewEOS.vc.Sv)


# wrapper function for the above function - can deal with values outside the range of the curve
def vapor_curve_S(P, phase='l'):
    res = None
    if phase == 'l':
        res = np.piecewise(P,
                           [P < 2e-6, np.logical_and(P > 2e-6, P < P_critical_point), P > P_critical_point],
                           [2251, PS_vapor_dome_l, S_critical_point])
    if phase == 'v':
        res = np.piecewise(P,
                           [P < 2e-6, np.logical_and(P > 2e-6, P < P_critical_point), P > P_critical_point],
                           [16218, PS_vapor_dome_v, S_critical_point])
    return res


# calculates the density of a liquid on the vapor curve as a function of P
P_rho_vapor_curve_l = interp1d(NewEOS.vc.Pl, NewEOS.vc.rl)


# wrapper for the above function - can deal with values outside the range of the curve
def rho_liquid_vc(P):
    return np.piecewise(P,
                        [P < 1.7e-6, np.logical_and(P > 1.7e-6, P < NewEOS.vc.Pl[0]), P > NewEOS.vc.Pl[0]],
                        [3.11, P_rho_vapor_curve_l, 0.57])


# calculates the absorption of the liquid vapor mix
# does not use unyt
def alpha_l(rho, P, S, D0):
    # uses the lever rule to calculate the vapor quality
    Sl = vapor_curve_S(P, phase='l')
    Sv = vapor_curve_S(P, phase='v')
    vq = np.where(P < P_critical_point, (S - Sl) / (Sv - Sl), 0)

    # calculates the liquid volume fraction from the vapor quality
    rho_l = rho_liquid_vc(P)
    lvf = (1 - vq) * (rho / rho_l)
    return (6 / (4 * D0)) * lvf


# calculates the absorption of a substance
# uses unyt
def alpha(rho, T, P, S, D0=1e-3):

    rho.convert_to_cgs()
    T.convert_to_units(K)
    P.convert_to_units(Pa)
    S.convert_to_units(J/K/kg)

    rho, T, P, S = np.array(rho), np.array(T), np.array(P), np.array(S)

    min_P = 1e-5

    phase = np.zeros_like(rho)
    phase = np.where(P <= min_P, 0, phase)
    phase = np.where(np.logical_and(P < S_P_vapor_dome(S), P > min_P), 2, phase)
    phase = np.where(np.logical_and(P > S_P_vapor_dome(S), S < S_critical_point), 1, phase)
    phase = np.where(np.logical_and(P > S_P_vapor_dome(S), S > S_critical_point), 3, phase)

    result = np.zeros_like(rho)
    result = np.where(phase == 0, 0, result)
    result = np.where(phase == 1, 1e12, result)
    if D0 != 0:
        result = np.where(phase == 2, alpha_v(rho, T) + alpha_l(rho, P, S, D0), result)
    else:
        result = np.where(phase == 2, alpha_v(rho, T), result)
    result = np.where(phase == 3, alpha_v(rho, T), result)

    return result * (m ** -1)


def test():
    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    def test_reverse_EOS(rho_test, T_test):
        S = S_woma([rho_test, T_test]) * J / K / kg
        P = P_woma([rho_test, T_test]) * Pa
        print(S)
        print(P)
        rho_check = rho(S, P)
        T_check = T(S, P)
        assert (rho_check.value - rho_test) / rho_test < 0.1
        assert (T_check.value - T_test) / T_test < 0.1

    test_reverse_EOS(1e-5, 2900)

    print(alpha(1e-5*g*cm**-3, 2900*K, 1e3*Pa, 9000*J/K/kg))
    print(alpha(1e-5*g*cm**-3, 2900*K, 1e3*Pa, 9000*J/K/kg, D0=0))


test()
