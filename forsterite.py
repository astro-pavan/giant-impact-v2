# Calculates the thermodynamic properties and opacity of forsterite using the ANEOS-2019 model and Kraus (2012)
import matplotlib.pyplot as plt
import numpy as np
import unyt

np.set_printoptions(precision=3)
from scipy.interpolate import RegularGridInterpolator, interp1d, interp2d
from scipy.optimize import minimize
import woma
from unyt import g, cm, K, J, kg, Pa, m, s

import sys
import os

sys.path.append(f'{os.getcwd()}/aneos-forsterite-2019-1.0.0')
import eostable

print('Loading EOS tables...')

# loads the eos table from file
NewEOS = eostable.extEOStable()  # FIRST make new empty EOS object

# LOAD EXTENDED 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadextsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-EXT.TXT')
# LOAD STANDARD 301 SESAME FILE GENERATED BY STSM VERSION OF ANEOS
NewEOS.loadstdsesame('aneos-forsterite-2019-1.0.0/NEW-SESAME-STD.TXT')

NewEOS.MODELNAME = 'Forsterite-ANEOS-SLVTv1.0G1'  # string set above in user input
NewEOS.MDQ = np.zeros((NewEOS.NT, NewEOS.ND))  # makes the empty MDQ array

NewEOS.MATID = 1.0
NewEOS.DATE = 190802
NewEOS.VERSION = 0.1
NewEOS.FMN = 70.
NewEOS.FMW = 140.691
NewEOS.R0REF = 3.22
NewEOS.K0REF = 1.1E12
NewEOS.T0REF = 298.
NewEOS.P0REF = 1.E6

NewEOS.loadaneos(aneosinfname='aneos-forsterite-2019-1.0.0/ANEOS.INPUT',
                 aneosoutfname='aneos-forsterite-2019-1.0.0/ANEOS.OUTPUT', silent=True)
woma.load_eos_tables()

# need to change the units to SI
NewEOS.P, NewEOS.S = NewEOS.P * 1e9, NewEOS.S * 1e6
NewEOS.vc.Sl, NewEOS.vc.Sv = NewEOS.vc.Sl * 1e6, NewEOS.vc.Sv * 1e6
NewEOS.vc.Pl, NewEOS.vc.Pv = NewEOS.vc.Pl * 1e9, NewEOS.vc.Pv * 1e9
NewEOS.U = NewEOS.U * 1e6
NewEOS.cs = NewEOS.cs / 100
P_critical_point, S_critical_point = NewEOS.cp.P * 1e9, NewEOS.cp.S * 1e6

print('EOS tables loaded')


# calculates rho and T from S and P from the NewEOS table
# does not use unyt
def reverse_EOS_table_SP(S, P):
    # calculates the log of the error between the target (S,P) and all the points in the EOS table
    log_error = np.log10(np.abs(NewEOS.S - S) / S + np.abs(NewEOS.P - P) / P)

    # finds the point in the table with the lowest error (hence closest to the target (S,P))
    k = log_error.argmin()
    ncol = log_error.shape[1]
    i, j = int(k / ncol), int(k % ncol)
    rho_guess, T_guess = NewEOS.rho[j], NewEOS.T[i]

    # wrapper function for woma EOS
    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    # function that calculates the error between guess and target (S,P)
    woma_error = lambda x: np.abs(S_woma(x) - S) / S + np.abs(P_woma(x) - P) / P

    # uses scipy to minimize this error
    res = minimize(woma_error, np.array([rho_guess, T_guess]), method='Nelder-Mead')
    rho_res, T_res = res.x

    # checks error to make sure it is not too big
    S_error = np.abs(S_woma([rho_res, T_res]) - S) / P
    P_error = np.abs(P_woma([rho_res, T_res]) - P) / P
    if S_error > 1 or P_error > 1:
        print(f'ERROR: error at P = {P} S = {S} exceeds 1')
    elif S_error > 0.1 or P_error > 0.1:
        print(f'WARNING: error at P = {P} S = {S} exceeds 0.1')

    return rho_res, T_res


# blank interpolators for rho and T
rho_interpolation, T_interpolation, T2_interpolation = lambda x: x, lambda x: x, lambda x: x
S_range, P_range = [4000, 12000], [1, 10]


u_interpolation = RegularGridInterpolator((NewEOS.rho, NewEOS.T), NewEOS.U.T, method='cubic', bounds_error=False, fill_value=np.NaN)
cs_interpolation = RegularGridInterpolator((NewEOS.rho, NewEOS.T), NewEOS.cs.T, method='cubic')


# generates the SP EOS table for interpolation
# does not use unyt
def generate_SP_table():
    global rho_interpolation, T_interpolation

    # produces table points to be calculated
    S = np.linspace(S_range[0], S_range[1], num=50)  # in J/K/kg
    logP = np.linspace(P_range[0], P_range[1], num=50)  # in log10(Pa)
    x, y = np.meshgrid(S, logP)
    rho_table = np.zeros_like(x)
    T_table = np.zeros_like(x)

    # fills table values
    for i in range(x.shape[0]):
        for j in range(x.shape[1]):
            rho_table[j, i], T_table[j, i] = reverse_EOS_table_SP(x[i, j], 10 ** y[i, j])

    rho_interpolation = RegularGridInterpolator((S, logP), rho_table, method='cubic')
    T_interpolation = RegularGridInterpolator((S, logP), T_table, method='cubic')


def generate_u_rho_table():
    global T2_interpolation

    u = np.linspace(0, 5e7, num=50)
    log_rho = np.linspace(-7, 2, num=50)
    x, y = np.meshgrid(u, log_rho)
    T_table = np.zeros_like(x)

    for i in range(x.shape[0]):
        for j in range(x.shape[1]):
            T_table[j, i] = woma.T_u_rho(x[i, j], (10 ** y[i, j]) * 1e3, 400)

    T2_interpolation = RegularGridInterpolator((u, log_rho), T_table, method='cubic')


print('Generating EOS table...')
#generate_u_rho_table()
generate_SP_table()
print('EOS table generated')


# calculates rho from S and P, takes numpy array inputs
# uses unyt
def rho_EOS(S, P):
    S.convert_to_mks()
    P.convert_to_mks()

    valid_region_mask = (S.value > S_range[0]) & (S.value < S_range[1]) &\
                        (np.log10(P.value) > P_range[0]) & (np.log10(P.value) < P_range[1])

    S = np.where(valid_region_mask, S, 5000) * J / K / kg
    P = np.where(valid_region_mask, P, 1e7) * Pa
    SP = np.array([S.value, np.log10(P.value)])

    return np.where(valid_region_mask, rho_interpolation(SP.T), np.NaN) * g * cm ** -3


# calculates T from S and P, takes numpy array inputs
# uses unyt
def T_EOS(S, P):
    S.convert_to_mks()
    P.convert_to_mks()

    valid_region_mask = (S.value > S_range[0]) & (S.value < S_range[1]) & \
                        (np.log10(P.value) > P_range[0]) & (np.log10(P.value) < P_range[1])

    S = np.where(valid_region_mask, S, 5000) * J / K / kg
    P = np.where(valid_region_mask, P, 1e7) * Pa
    SP = np.array([S.value, np.log10(P.value)])

    return np.where(valid_region_mask, T_interpolation(SP.T), np.NaN) * K


def T2_EOS(u, rho):
    rho.convert_to_units(g / cm ** 3)
    u.convert_to_mks()

    u_rho = np.array([u, rho])

    return T2_interpolation(u_rho.T)


# calculates u from rho and T, takes numpy array inputs
# uses unyt
def u_EOS(rho, T):
    rho.convert_to_units(g / cm ** 3)
    T.convert_to_units(K)
    rhoT = np.array([rho.value, T.value])
    return u_interpolation(rhoT.T) * (J / kg)


def cs_EOS(rho, T):
    rho.convert_to_units(g / cm ** 3)
    T.convert_to_units(K)
    rhoT = np.array([rho.value, T.value])
    return cs_interpolation(rhoT.T) * (m / s)


# defines the vapor dome - giving P as a function of S
S_vapor_dome = np.concatenate([[0], np.flip(NewEOS.vc.Sl), NewEOS.vc.Sv])
P_vapor_dome = np.concatenate([[1e-7], np.flip(NewEOS.vc.Pl), NewEOS.vc.Pv])
S_P_vapor_dome = interp1d(S_vapor_dome, P_vapor_dome)


# finds the phase
# 0 : invalid region
# 1 : liquid/solid
# 2 : liquid vapor mix
# 3 : vapor
def phase(S, P):
    P.convert_to_units(Pa)
    S.convert_to_units(J / K / kg)

    min_P = 1e-5  # pressures below this are invalid

    result = np.zeros_like(P)
    result = np.where(P <= min_P, 0, result)
    result = np.where(np.logical_and(P < S_P_vapor_dome(S), P > min_P), 2, result)
    result = np.where(np.logical_and(P > S_P_vapor_dome(S), S < S_critical_point), 1, result)
    result = np.where(np.logical_and(P > S_P_vapor_dome(S), S > S_critical_point), 3, result)

    return result


# calculates the absorption of the vapor
# does not use unyt
def alpha_v(rho, T):
    B0 = 6e17  # m^-1
    B1, B2 = 37, -11.6
    rho_n, T_n = 1.9, 4150  # g/cm^3, K
    r, t = rho / rho_n, T / T_n

    return B0 * (r ** (1 / 3)) * t * np.exp(-B1 / t) * np.exp(-B2 * (r / t))


# gives the vapor dome - giving S as a function of P for the liquid and vapor parts
PS_vapor_dome_l, PS_vapor_dome_v = interp1d(NewEOS.vc.Pl, NewEOS.vc.Sl), interp1d(NewEOS.vc.Pv, NewEOS.vc.Sv)


# wrapper function for the above function - can deal with values outside the range of the curve
def vapor_curve_S(P, phase='l'):
    res = None
    if phase == 'l':
        res = np.piecewise(P,
                           [P < 2e-6, np.logical_and(P > 2e-6, P < P_critical_point), P > P_critical_point],
                           [2251, PS_vapor_dome_l, S_critical_point])
    if phase == 'v':
        res = np.piecewise(P,
                           [P < 2e-6, np.logical_and(P > 2e-6, P < P_critical_point), P > P_critical_point],
                           [16218, PS_vapor_dome_v, S_critical_point])
    return res


# calculates the density of a liquid on the vapor curve as a function of P
P_rho_vapor_curve_l = interp1d(NewEOS.vc.Pl, NewEOS.vc.rl)


# wrapper for the above function - can deal with values outside the range of the curve
def rho_liquid_vc(P):
    return np.piecewise(P,
                        [P < 1.7e-6, np.logical_and(P > 1.7e-6, P < NewEOS.vc.Pl[0]), P > NewEOS.vc.Pl[0]],
                        [3.11, P_rho_vapor_curve_l, 0.57])


# calculates the absorption of the liquid vapor mix
# does not use unyt
def alpha_l(rho, P, S, D0):
    # uses the lever rule to calculate the vapor quality
    Sl = vapor_curve_S(P, phase='l')
    Sv = vapor_curve_S(P, phase='v')
    vq = np.where(P < P_critical_point, (S - Sl) / (Sv - Sl), 0)

    # calculates the liquid volume fraction from the vapor quality
    rho_l = rho_liquid_vc(P)
    lvf = (1 - vq) * (rho / rho_l)
    return (6 / (4 * D0)) * lvf


# calculates the absorption of a substance
# uses unyt
def alpha(rho, T, P, S, D0=1e-3):

    rho.convert_to_cgs()
    T.convert_to_units(K)
    P.convert_to_units(Pa)
    S.convert_to_units(J/K/kg)

    rho, T, P, S = np.array(rho), np.array(T), np.array(P), np.array(S)

    min_P = 1e-5

    phase = np.zeros_like(rho)
    phase = np.where(P <= min_P, 0, phase)
    phase = np.where(np.logical_and(P < S_P_vapor_dome(S), P > min_P), 2, phase)
    phase = np.where(np.logical_and(P > S_P_vapor_dome(S), S < S_critical_point), 1, phase)
    phase = np.where(np.logical_and(P > S_P_vapor_dome(S), S > S_critical_point), 3, phase)

    result = np.zeros_like(rho)
    result = np.where(phase == 0, 0, result)
    result = np.where(phase == 1, 1e12, result)
    if D0 != 0:
        result = np.where(phase == 2, alpha_v(rho, T) + alpha_l(rho, P, S, D0), result)
    else:
        result = np.where(phase == 2, alpha_v(rho, T), result)
    result = np.where(phase == 3, alpha_v(rho, T), result)

    return result * (m ** -1)


def big_plot():

    S = np.linspace(3000, 15000, num=60)
    P = np.logspace(0, 10, num=60)
    x, y = np.meshgrid(S, P)
    x, y = x * J/K/kg, y * Pa

    rho = rho_EOS(x, y)
    T = T_EOS(x, y)

    z = np.log10(alpha(rho, T, y, x, D0=0))

    plt.contourf(x, y, z, 100, cmap='plasma')
    plt.plot(NewEOS.vc.Sl, NewEOS.vc.Pl, 'k--')
    plt.plot(NewEOS.vc.Sv, NewEOS.vc.Pv, 'k--')
    plt.yscale('log')
    plt.colorbar()
    plt.show()


def test():
    S_woma = lambda x: woma.s_rho_T(x[0] * 1e3, x[1], 400)
    P_woma = lambda x: woma.P_T_rho(x[1], x[0] * 1e3, 400)

    def test_reverse_EOS(rho_test, T_test):
        S = S_woma([rho_test, T_test]) * J / K / kg
        P = P_woma([rho_test, T_test]) * Pa
        print(S)
        print(P)
        rho_check = rho_EOS(S, P)
        T_check = T_EOS(S, P)
        assert (rho_check.value - rho_test) / rho_test < 0.1
        assert (T_check.value - T_test) / T_test < 0.1

    test_reverse_EOS(1e-5, 2900)

    print(alpha(1e-5*g*cm**-3, 2900*K, 1e3*Pa, 9000*J/K/kg))
    print(alpha(1e-5*g*cm**-3, 2900*K, 1e3*Pa, 9000*J/K/kg, D0=0))

    print(u_EOS(1e-3 * g / cm ** 3, 3000 * K))
    print(woma.u_rho_T(1, 3000, 400))

    print(u_EOS(1e-5 * g / cm ** 3, 2700 * K))
    print(woma.u_rho_T(1e-2, 2700, 400))

    S = np.array([[6000, 9000], [6000, 9000]]) * J / K / kg
    P = np.array([[1e5, 1e3], [1e5, 1e3]]) * Pa

    print(rho_EOS(S, P))

